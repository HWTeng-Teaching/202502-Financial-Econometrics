#Q1

x <- c(3, 2, 1, -1, 0)
y <- c(4, 2, 3, 1, 0)

# 計算平均值
x_bar <- mean(x)
y_bar <- mean(y)

# 計算 b1
b2 <- sum((x - x_bar) * (y - y_bar)) / sum((x - x_bar)^2)

# 計算 b0
b1 <- y_bar - b1 * x_bar

# 輸出結果
b2  # 斜率
b1  # 截距

# 計算 Σ(x_i^2) 和 Σ(x_i * y_i)
sum_x2 <- sum(x^2)
sum_xy <- sum(x * y)

# 計算 Σ(x_i - x̄)^2
sum_x_minus_xbar2 <- sum((x - x_bar)^2)

# 驗證公式 Σ(x_i - x̄)^2 = Σ(x_i^2) - N * x̄^2
lhs_1 <- sum_x_minus_xbar2
rhs_1 <- sum_x2 - N * x_bar^2
check_1 <- all.equal(lhs_1, rhs_1)

# 計算 Σ(x_i - x̄)(y_i - ȳ)
sum_x_minus_xbar_y_minus_ybar <- sum((x - x_bar) * (y - y_bar))

# 驗證公式 Σ(x_i - x̄)(y_i - ȳ) = Σ(x_i * y_i) - N * x̄ * ȳ
lhs_2 <- sum_x_minus_xbar_y_minus_ybar
rhs_2 <- sum_xy - N * x_bar * y_bar
check_2 <- all.equal(lhs_2, rhs_2)

#Q1d
x <- c(3, 2, 1, -1, 0)
y <- c(4, 2, 3, 1, 0)

# 計算回歸係數
model <- lm(y ~ x)
b0 <- coef(model)[1]  # 截距
b1 <- coef(model)[2]  # 斜率

# 計算擬合值 (y_hat)
y_hat <- b0 + b1 * x

# 計算殘差 (e_i)
e <- y - y_hat

# 計算殘差平方 (e^2)
e_sq <- e^2

# 計算 x_i * e_i
x_e <- x * e

# 計算統計量
N <- length(x)
x_bar <- mean(x)
y_bar <- mean(y)

# 變異數
s2_y <- sum((y - y_bar)^2) / (N - 1)
s2_x <- sum((x - x_bar)^2) / (N - 1)

# 共變數
s_xy <- sum((y - y_bar) * (x - x_bar)) / (N - 1)

# 相關係數
r_xy <- s_xy / sqrt(s2_x * s2_y)

# 變異係數 CV_x
CV_x <- 100 * (sqrt(s2_x) / x_bar)

# 中位數
median_x <- median(x)

# 結果輸出
table_df <- data.frame(x, y, y_hat, e, e_sq, x_e)
print(table_df)

# Q16
#讀資料
temp_file <- tempfile(fileext = ".rdata")


download.file(url = "https://www.principlesofeconometrics.com/poe5/data/rdata/capm5.rdata", 
              destfile = temp_file, 
              mode = "wb")  

load(temp_file)
capm5

firms <- c("ge", "ibm", "ford", "msft", "dis", "xom")
market_r <- "mkt"
riskfree_r <- "riskfree" 

#計算市場超額報酬以及公司超額報酬，兩者跑回歸
capm5$MKT_excess <- capm5[[market_r]] - capm5[[riskfree_r]]
results <- data.frame(Firm = firms, Beta = numeric(length(firms)))
for(i in 1:length(firms)) {
  
  firm_excess <- capm5[[firms[i]]] - capm5[[riskfree_r]]
  

  model <- lm(firm_excess ~ capm5$MKT_excess)
  
  
  results$Alpha[i] <- coef(model)[1]
  results$Beta[i] <- coef(model)[2]
}
print(results)

#得到alpha p值
p_values <- list()
p_value <- summary(model)$coefficients[1, 4] 取第二行（X），第四列（p 值）
print(p_value)

#計算MSFT的回歸線跟點圖
library(ggplot2)
msft_excess <- capm5$msft - capm5$riskfree

# 取出市場超額報酬
market_excess <- capm5$MKT_excess

# 建立線性回歸模型
lm_msft <- lm(msft_excess ~ market_excess)

# 繪製散點圖
plot(market_excess, msft_excess,
     main = "CAPM for Microsoft",
     xlab = "市場超額報酬",
     ylab = "MSFT超額報酬",
     pch = 19,       # 點的形狀
     col = "yellow")   # 點的顏色
# 加入回歸直線
abline(lm_msft, col = "red", linetype = "dashed")

計算alpha為0的capm
results_no_intercept <- data.frame(
  Firm = firms,
  Beta = numeric(length(firms))  # 預先放置 Beta (無截距) 的欄位
)
for (i in seq_along(firms)) {
  
  # 公司超額報酬 (R_i - R_f)
  firm_excess <- capm5[[firms[i]]] - capm5$riskfree
  
  model_no_intercept <- lm(firm_excess ~ 0 + capm5$MKT_excess)
  
  results_no_intercept$Beta[i] <- coef(model_no_intercept)[1]
}
